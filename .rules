# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Build and Development Commands

**Build and run (debug):**
```sh
cargo run
```

**Build and run (release CLI):**
```sh
cargo run -p cli
```

**Run tests:**
```sh
cargo test --workspace
```

**Run a single test:**
```sh
cargo test -p <crate_name> <test_name>
```

**Lint (use this instead of `cargo clippy`):**
```sh
./script/clippy
```

**Install dependencies (Linux):**
```sh
script/linux
```

**Install local development build:**
```sh
./script/install-linux
```

## High-Level Architecture

This is a fork of [Zed](https://github.com/zed-industries/zed), a GPU-accelerated code editor. Key crates:

- **gpui** (`crates/gpui`): GPU-accelerated UI framework providing state management, concurrency primitives, and rendering. The core abstraction layer.
- **zed** (`crates/zed`): Main application entry point that ties everything together.
- **editor** (`crates/editor`): Core text editor component used for both code editing and input fields. Handles LSP display features.
- **workspace** (`crates/workspace`): Window management, local state serialization, and project grouping.
- **project** (`crates/project`): File management, navigation, and LSP communication.
- **language** (`crates/language`): Language understanding including syntax trees and symbol lists.
- **lsp** (`crates/lsp`): LSP server communication.
- **vim** (`crates/vim`): Vim mode implementation over the editor.
- **ui** (`crates/ui`): Shared UI components and patterns.
- **collab** (`crates/collab`): Collaboration server for project sharing.
- **terminal** / **terminal_view** (`crates/terminal`, `crates/terminal_view`): Terminal emulator with SSH/Telnet session management and automation rule engine.
- **remote_explorer** (`crates/remote_explorer`): Panel for browsing and managing saved SSH/Telnet sessions in a tree view.
- **rule_editor** (`crates/rule_editor`): Panel for managing terminal automation rules (auto-login, pattern-based actions).

## Rust Coding Guidelines

* Prioritize code correctness and clarity. Speed and efficiency are secondary priorities unless otherwise specified.
* Do not write organizational or comments that summarize the code. Comments should only be written in order to explain "why" the code is written in some way in the case there is a reason that is tricky / non-obvious.
* Prefer implementing functionality in existing files unless it is a new logical component. Avoid creating many small files.
* Avoid using functions that panic like `unwrap()`, instead use mechanisms like `?` to propagate errors.
* Be careful with operations like indexing which may panic if the indexes are out of bounds.
* Never silently discard errors with `let _ =` on fallible operations. Always handle errors appropriately:
  - Propagate errors with `?` when the calling function should handle them
  - Use `.log_err()` or similar when you need to ignore errors but want visibility
  - Use explicit error handling with `match` or `if let Err(...)` when you need custom logic
  - Example: avoid `let _ = client.request(...).await?;` - use `client.request(...).await?;` instead
* When implementing async operations that may fail, ensure errors propagate to the UI layer so users get meaningful feedback.
* Never create files with `mod.rs` paths - prefer `src/some_module.rs` instead of `src/some_module/mod.rs`.
* When creating new crates, prefer specifying the library root path in `Cargo.toml` using `[lib] path = "...rs"` instead of the default `lib.rs`, to maintain consistent and descriptive naming (e.g., `gpui.rs` or `main.rs`).
* Avoid creative additions unless explicitly requested
* Use full words for variable names (no abbreviations like "q" for "queue")
* Use variable shadowing to scope clones in async contexts for clarity, minimizing the lifetime of borrowed references.
  Example:
  ```rust
  executor.spawn({
      let task_ran = task_ran.clone();
      async move {
          *task_ran.borrow_mut() = true;
      }
  });
  ```

# Timers in tests

* In GPUI tests, prefer GPUI executor timers over `smol::Timer::after(...)` when you need timeouts, delays, or to drive `run_until_parked()`:
  - Use `cx.background_executor().timer(duration).await` (or `cx.background_executor.timer(duration).await` in `TestAppContext`) so the work is scheduled on GPUI's dispatcher.
  - Avoid `smol::Timer::after(...)` for test timeouts when you rely on `run_until_parked()`, because it may not be tracked by GPUI's scheduler and can lead to "nothing left to run" when pumping.

# GPUI

GPUI is a UI framework which also provides primitives for state and concurrency management.

## Context

Context types allow interaction with global state, windows, entities, and system services. They are typically passed to functions as the argument named `cx`. When a function takes callbacks they come after the `cx` parameter.

* `App` is the root context type, providing access to global state and read and update of entities.
* `Context<T>` is provided when updating an `Entity<T>`. This context dereferences into `App`, so functions which take `&App` can also take `&Context<T>`.
* `AsyncApp` and `AsyncWindowContext` are provided by `cx.spawn` and `cx.spawn_in`. These can be held across await points.

## `Window`

`Window` provides access to the state of an application window. It is passed to functions as an argument named `window` and comes before `cx` when present. It is used for managing focus, dispatching actions, directly drawing, getting user input state, etc.

## Entities

An `Entity<T>` is a handle to state of type `T`. With `thing: Entity<T>`:

* `thing.entity_id()` returns `EntityId`
* `thing.downgrade()` returns `WeakEntity<T>`
* `thing.read(cx: &App)` returns `&T`.
* `thing.read_with(cx, |thing: &T, cx: &App| ...)` returns the closure's return value.
* `thing.update(cx, |thing: &mut T, cx: &mut Context<T>| ...)` allows the closure to mutate the state, and provides a `Context<T>` for interacting with the entity. It returns the closure's return value.
* `thing.update_in(cx, |thing: &mut T, window: &mut Window, cx: &mut Context<T>| ...)` takes a `AsyncWindowContext` or `VisualTestContext`. It's the same as `update` while also providing the `Window`.

Within the closures, the inner `cx` provided to the closure must be used instead of the outer `cx` to avoid issues with multiple borrows.

Trying to update an entity while it's already being updated must be avoided as this will cause a panic.

When  `read_with`, `update`, or `update_in` are used with an async context, the closure's return value is wrapped in an `anyhow::Result`.

`WeakEntity<T>` is a weak handle. It has `read_with`, `update`, and `update_in` methods that work the same, but always return an `anyhow::Result` so that they can fail if the entity no longer exists. This can be useful to avoid memory leaks - if entities have mutually recursive handles to each other they will never be dropped.

## Concurrency

All use of entities and UI rendering occurs on a single foreground thread.

`cx.spawn(async move |cx| ...)` runs an async closure on the foreground thread. Within the closure, `cx` is `&mut AsyncApp`.

When the outer cx is a `Context<T>`, the use of `spawn` instead looks like `cx.spawn(async move |this, cx| ...)`, where `this: WeakEntity<T>` and `cx: &mut AsyncApp`.

To do work on other threads, `cx.background_spawn(async move { ... })` is used. Often this background task is awaited on by a foreground task which uses the results to update state.

Both `cx.spawn` and `cx.background_spawn` return a `Task<R>`, which is a future that can be awaited upon. If this task is dropped, then its work is cancelled. To prevent this one of the following must be done:

* Awaiting the task in some other async context.
* Detaching the task via `task.detach()` or `task.detach_and_log_err(cx)`, allowing it to run indefinitely.
* Storing the task in a field, if the work should be halted when the struct is dropped.

A task which doesn't do anything but provide a value can be created with `Task::ready(value)`.

## Elements

The `Render` trait is used to render some state into an element tree that is laid out using flexbox layout. An `Entity<T>` where `T` implements `Render` is sometimes called a "view".

Example:

```
struct TextWithBorder(SharedString);

impl Render for TextWithBorder {
    fn render(&mut self, _window: &mut Window, _cx: &mut Context<Self>) -> impl IntoElement {
        div().border_1().child(self.0.clone())
    }
}
```

Since `impl IntoElement for SharedString` exists, it can be used as an argument to `child`. `SharedString` is used to avoid copying strings, and is either an `&'static str` or `Arc<str>`.

UI components that are constructed just to be turned into elements can instead implement the `RenderOnce` trait, which is similar to `Render`, but its `render` method takes ownership of `self` and receives `&mut App` instead of `&mut Context<Self>`. Types that implement this trait can use `#[derive(IntoElement)]` to use them directly as children.

The style methods on elements are similar to those used by Tailwind CSS.

If some attributes or children of an element tree are conditional, `.when(condition, |this| ...)` can be used to run the closure only when `condition` is true. Similarly, `.when_some(option, |this, value| ...)` runs the closure when the `Option` has a value.

## Input events

Input event handlers can be registered on an element via methods like `.on_click(|event, window, cx: &mut App| ...)`.

Often event handlers will want to update the entity that's in the current `Context<T>`. The `cx.listener` method provides this - its use looks like `.on_click(cx.listener(|this: &mut T, event, window, cx: &mut Context<T>| ...)`.

## Drag and Drop

### Classic Pitfall: `on_drag_move` fires for ALL registered handlers

`on_drag_move` events fire during the Capture phase, which means ALL elements with registered `on_drag_move` handlers will receive the event, regardless of where the mouse actually is. This can cause unexpected behavior where a "background" or "blank-area" handler overwrites the target set by specific item handlers.

**Wrong:**
```rust
// Background area - this handler fires even when mouse is over list items!
div()
    .id("blank-area")
    .on_drag_move::<DraggedItem>(cx.listener(
        |this, _event, _window, cx| {
            this.drag_target = Some(DragTarget::Root);  // Overwrites item targets!
            cx.notify();
        },
    ))
```

**Correct:**
```rust
// Background area - check bounds before setting target
div()
    .id("blank-area")
    .on_drag_move::<DraggedItem>(cx.listener(
        |this, event: &DragMoveEvent<DraggedItem>, _window, cx| {
            if event.bounds.contains(&event.event.position) {
                this.drag_target = Some(DragTarget::Root);
                cx.notify();
            }
        },
    ))
```

Always use `event.bounds.contains(&event.event.position)` in `on_drag_move` handlers to ensure the mouse is actually within the element's bounds. See `project_panel` for reference implementation.

## Actions

Actions are dispatched via user keyboard interaction or in code via `window.dispatch_action(SomeAction.boxed_clone(), cx)` or `focus_handle.dispatch_action(&SomeAction, window, cx)`.

Actions with no data defined with the `actions!(some_namespace, [SomeAction, AnotherAction])` macro call. Otherwise the `Action` derive macro is used. Doc comments on actions are displayed to the user.

Action handlers can be registered on an element via the event handler `.on_action(|action, window, cx| ...)`. Like other event handlers, this is often used with `cx.listener`.

## Keyboard Shortcuts and Key Bindings

GPUI provides a comprehensive system for handling keyboard shortcuts, from single keys to multi-keystroke sequences.

### Key Files

| Purpose | File Path |
|---------|-----------|
| Keystroke parsing | `crates/gpui/src/platform/keystroke.rs` |
| KeyBinding structure | `crates/gpui/src/keymap/binding.rs` |
| Keymap management | `crates/gpui/src/keymap.rs` |
| Context matching | `crates/gpui/src/keymap/context.rs` |
| Key dispatch tree | `crates/gpui/src/key_dispatch.rs` |
| Action definition | `crates/gpui/src/action.rs` |
| Window event handling | `crates/gpui/src/window.rs` |
| Element interaction | `crates/gpui/src/elements/div.rs` |

### Keystroke Format

```
Format: [secondary-][ctrl-][alt-][shift-][cmd-][fn-]key
Examples: "a", "ctrl-a", "shift-enter", "cmd-k left" (multi-keystroke sequence)
```

### Defining Actions

**Simple actions (no data):**
```rust
actions!(editor, [MoveUp, MoveDown, MoveLeft, MoveRight]);
```

**Actions with data:**
```rust
#[derive(Clone, PartialEq, Deserialize, JsonSchema, Action)]
#[action(namespace = editor)]
#[serde(deny_unknown_fields)]
pub struct SelectNext {
    #[serde(default)]
    pub replace_newest: bool,
}
```

### Registering Key Bindings

```rust
KeyBinding::new("cmd-z", UndoAction, Some("Editor"))  // With context
KeyBinding::new("ctrl-k left", SomeAction, None)       // Multi-keystroke, no context
```

**Context predicate syntax:**
- `"Editor"` - simple component name
- `"editor && vim_mode == normal"` - AND combination
- `"!(editor)"` - negation
- `"Workspace > Editor"` - ancestor-descendant relationship

### Registering Action Handlers on Elements

**Named action handlers:**
```rust
div()
    .key_context("Editor")  // Scope bindings to this context
    .on_action(cx.listener(Self::handle_undo))
    .on_action(cx.listener(Self::handle_redo))
```

**Raw key event handlers:**
```rust
div()
    .on_key_down(cx.listener(|this, event, window, cx| {
        // Handle KeyDownEvent
        if should_consume {
            cx.stop_propagation();  // Prevent bubbling
        }
    }))
    .capture_key_down(cx.listener(|this, event, window, cx| {
        // Capture phase handler (fires before bubble)
    }))
```

### Handler Context Types

| Context Type | Purpose | Available In |
|-------------|---------|--------------|
| `&A` | Action data | All handlers |
| `&mut Window` | Window operations | All handlers |
| `&mut App` | Global state, spawn tasks | All handlers |
| `&mut Context<T>` | Entity-specific: notify, subscribe | Via `cx.listener()` |
| `DispatchPhase` | Capture or Bubble phase | Window-level `on_action` only |

### Event Dispatch Phases

```rust
pub enum DispatchPhase {
    Capture,  // Root → Focused element (fires first)
    Bubble,   // Focused element → Root (default)
}
```

Events propagate in two phases:
1. **Capture**: From root down to focused element
2. **Bubble**: From focused element up to root

Call `cx.stop_propagation()` to prevent further propagation.

### Multi-Keystroke Sequences

Multi-keystroke bindings (e.g., `"ctrl-k left"`) use a pending state machine:
1. First keystroke partially matches → stored in pending state
2. Subsequent keystrokes complete the sequence → action executed
3. 1-second timeout → pending keystrokes replayed as individual events

### Tab Key Handling

Tab is **not** automatically handled. Explicit binding required:

```rust
actions!(example, [Tab, TabPrev]);

cx.bind_keys([
    KeyBinding::new("tab", Tab, None),
    KeyBinding::new("shift-tab", TabPrev, None),
]);

fn on_tab(&mut self, _: &Tab, window: &mut Window, cx: &mut Context<Self>) {
    window.focus_next(cx);
}

fn on_tab_prev(&mut self, _: &TabPrev, window: &mut Window, cx: &mut Context<Self>) {
    window.focus_prev(cx);
}
```

### Complete Event Flow

```
Platform Key Event
    ↓
window.dispatch_key_event()
    ├─ Build dispatch path (root → focused element)
    ├─ Check keystroke interceptors
    ├─ Attempt multi-keystroke binding match
    ├─ If pending: Store and wait for timeout
    ├─ If matched: Execute binding
    │   └─ dispatch_action_on_node()
    │       ├─ Capture phase (root → focused)
    │       └─ Bubble phase (focused → root)
    └─ Else: Dispatch raw key events to listeners
```

## Notify

When a view's state has changed in a way that may affect its rendering, it should call `cx.notify()`. This will cause the view to be rerendered. It will also cause any observe callbacks registered for the entity with `cx.observe` to be called.

## Entity events

While updating an entity (`cx: Context<T>`), it can emit an event using `cx.emit(event)`. Entities register which events they can emit by declaring `impl EventEmitter<EventType> for EntityType {}`.

Other entities can then register a callback to handle these events by doing `cx.subscribe(other_entity, |this, other_entity, event, cx| ...)`. This will return a `Subscription` which deregisters the callback when dropped.  Typically `cx.subscribe` happens when creating a new entity and the subscriptions are stored in a `_subscriptions: Vec<Subscription>` field.

## Build guidelines

- Use `./script/clippy` instead of `cargo clippy`

## Session Management

The terminal crate includes a session management system for persistent SSH/Telnet configurations (`crates/terminal/src/session_store.rs`).

### Data Model

- `SessionNode`: Enum representing either a `Group` or `Session` in a tree structure
- `SessionGroup`: Folder containing other groups or sessions
- `SessionConfig`: Session configuration with name, tags, and protocol-specific settings
- `ProtocolConfig`: Enum for `Ssh` or `Telnet` configurations
- `AuthMethod`: Authentication options (Interactive, Password, PrivateKey, Agent)

### GPUI Integration

- `SessionStoreEntity`: GPUI entity wrapping `SessionStore` with auto-save and event emission
- `GlobalSessionStore`: Global marker for `cx.global()` access
- `SessionStoreEvent`: Events for UI subscription (Changed, SessionAdded, SessionRemoved)

### Usage

```rust
// Initialize on app startup
SessionStoreEntity::init(cx);

// Access globally
let sessions = SessionStoreEntity::global(cx);
sessions.update(cx, |store, cx| {
    store.add_session(config, parent_id, cx);
});

// Subscribe to changes
cx.subscribe(&sessions, |this, _, event, cx| {
    // Handle SessionStoreEvent
});
```

### Persistence

Sessions are stored in `~/.config/zed/sessions.json` (or platform equivalent via `paths::sessions_file()`).

## Telnet Connection

The terminal crate includes a Telnet connection module (`crates/terminal/src/connection/telnet/`) for connecting to remote hosts via the Telnet protocol.

### Module Structure

```
telnet/
  mod.rs          # TelnetConfig, exports
  protocol.rs     # Telnet IAC handling, option negotiation
  session.rs      # TelnetSession - TCP connection management
  terminal.rs     # TelnetTerminalConnection - implements TerminalConnection trait
```

### Protocol Implementation (`protocol.rs`)

- **IAC Commands**: IAC (255), DO (253), DONT (254), WILL (251), WONT (252), SB (250), SE (240)
- **Option Codes**: ECHO (1), SUPPRESS_GO_AHEAD (3), TERMINAL_TYPE (24), NAWS (31)
- `TelnetNegotiator`: Parses IAC sequences and generates appropriate responses
- `process_incoming()`: Separates terminal data from commands, returns protocol responses
- `build_naws()`: Generates window size subnegotiation packet (RFC 1073)
- IAC escaping: 255 255 → single 255

### TelnetConfig (`mod.rs`)

```rust
pub struct TelnetConfig {
    pub host: String,
    pub port: u16,
    pub username: Option<String>,
    pub password: Option<String>,
    pub encoding: Option<String>,
    pub terminal_type: String,  // default: "xterm-256color"
}
```

### TelnetSession (`session.rs`)

Manages TCP connection lifecycle:
- `connect()`: Establishes TCP connection, returns read/write halves for the channel task

### TelnetTerminalConnection (`terminal.rs`)

Implements `TerminalConnection` trait (same interface as SSH):
- Uses `TelnetChannelCommand` enum (Write, Resize, Close)
- Channel task with `futures::select_biased!` for concurrent I/O
- Automatic NAWS window size updates after negotiation

### Usage

```rust
// Create terminal with Telnet connection
let terminal = TerminalBuilder::new_with_telnet(
    telnet_config,
    cursor_shape,
    alternate_scroll,
    max_scroll_history_lines,
    window_id,
    cx,
    path_style,
).await?;

// Or connect via quick_add helper
connect_telnet(telnet_config, workspace, pane, window, cx);
```

### Converting from SessionStore config

```rust
use terminal::connection::telnet::TelnetConfig;

let telnet_session_config: TelnetSessionConfig = /* from session store */;
let config: TelnetConfig = (&telnet_session_config).into();
```

## Terminal Keybinding Interception

The terminal view intercepts keystrokes to decide whether they should be sent to the shell or handled by Zed's action system (`crates/terminal_view/src/terminal_view.rs`).

### Behavior

When `send_keybindings_to_shell` setting is enabled, keystrokes are intercepted and checked:

1. **Explicit skip list**: Keystrokes in `keybindings_to_skip_shell` setting are always handled by Zed
2. **Terminal-context bindings**: Only keybindings with `"context": "Terminal"` predicate are intercepted
3. **Global bindings**: Keybindings without a Terminal context predicate are sent to the shell

### Key Functions

- `should_skip_shell()`: Main decision function combining all checks
- `keystroke_has_zed_action_binding()`: Checks if keystroke has a Terminal-context keybinding
- `predicate_contains_terminal()`: Recursively checks if a `KeyBindingContextPredicate` contains "Terminal"

### Examples

| Keystroke | Action | Context | Result |
|-----------|--------|---------|--------|
| `ctrl-p` | `menu::SelectPrevious` | Global | Sent to shell |
| `ctrl-v` | `terminal::Paste` | Terminal | Intercepted by Zed |
| `ctrl-c` | `terminal::SendKeystroke` | Terminal | Sent to shell (explicitly forwarded) |
| `ctrl-shift-c` | `terminal::Copy` | Terminal | Intercepted by Zed |

### Special Actions

- `terminal::SendKeystroke` and `terminal::SendText` are always sent to the shell, even with Terminal context

## Remote Explorer Panel

The `remote_explorer` crate (`crates/remote_explorer`) provides a panel for browsing saved SSH/Telnet sessions in a tree view.

### Architecture

- Uses `UniformList` for virtual scrolling with flattened tree structure
- Indentation via `ListItem.indent_level()` with `px(12.)` step size
- Icons: `FolderOpen`/`Folder` for groups, `Server` for sessions
- Subscribes to `SessionStoreEvent` for automatic updates

### Key Components

- `FlattenedEntry`: Flattened tree entry with `id`, `depth`, and `node`
- `RemoteExplorer`: Main panel struct implementing `Panel`, `Focusable`, `Render`
- `init(cx)`: Initializes `SessionStoreEntity` and registers `ToggleFocus` action
- `load()`: Async loader for workspace panel initialization

### Integration Points

- **Action**: `zed_actions::remote_explorer::ToggleFocus`
- **Menu**: View > Remote Explorer
- **Icon**: Server icon in left dock
- **Position**: Left or Right dock (default: Left)
- **Priority**: `activation_priority = 10`

### Usage

```rust
// In app initialization (already done in zed crate)
remote_explorer::init(cx);

// Panel is automatically loaded via initialize_workspace()
let remote_explorer = RemoteExplorer::load(workspace_handle.clone(), cx.clone());
```

### Quick Add Area

The Remote Explorer panel includes a Quick Add area (`crates/remote_explorer/src/quick_add/`) for rapidly adding new connections.

#### Auto-Recognize Input

The auto-recognize input field (`auto_recognize.rs`) supports flexible parsing with IP detection anywhere in the input string.

| Format | Example | Session Name | Result |
|--------|---------|--------------|--------|
| IP only | `192.168.1.1` | "192.168.1.1" | Telnet on port 23 |
| IP:port | `192.168.1.1:22` | "192.168.1.1:22" | SSH on port 22 |
| IP user pass | `192.168.1.1 root password` | "192.168.1.1" | Telnet with credentials |
| IP user pass port | `192.168.1.1 root password 2323` | "192.168.1.1" | Telnet on custom port |
| Slash credentials | `192.168.1.1 user/pass` | "192.168.1.1" | Telnet, user/pass parsed |
| Name prefix | `管理网口127.0.0.1` | "管理网口127.0.0.1" | Telnet, name includes prefix |
| Name + credentials | `管理网口127.0.0.1 root/Root@123` | "管理网口127.0.0.1" | Telnet with credentials |
| Name with spaces | `dev server 192.168.1.1 root/pass` | "dev server 192.168.1.1" | Telnet with credentials |
| Name + port | `测试10.0.0.1:22 admin pass` | "测试10.0.0.1:22" | SSH with credentials |
| Multiple (comma) | `192.168.1.1, 192.168.1.2` | — | Multiple connections |
| Multiple (newline) | Line-separated IPs | — | Multiple connections |
| Session env info | `环境192.168.1.1\troot\tpass` | — | Telnet (see below) |
| Session env info | `后台192.168.1.1\tadmin\tpass` | — | SSH (see below) |

**Parsing Algorithm:**
1. Scans input to find IPv4 address anywhere in the string
2. Session name = everything from start up to and including IP:port
3. Credentials parsed from remaining text after IP:port
4. Supports multiple credential separators: tab (`\t`), slash (`/`), or space

**Credential Formats:**
- Tab-separated: `user\tpass`
- Slash-separated: `user/pass`
- Space-separated: `user pass` or `user pass port`

#### Session Env Info Format (环境/后台)

Special format for bulk importing sessions from "复制环境信息" (Copy Environment Info):

- **Telnet**: `环境<host>[:<port>]\t<username>\t<password>` (default port 23)
- **SSH**: `后台<host>[:<port>]\t<username>\t<password>` (default port 22)

**Import behavior:**
1. Entries are grouped by host IP address
2. A `SessionGroup` is created for each unique IP (group name = IP address)
3. All sessions for that IP are added to the group
4. Sessions are auto-saved without establishing connections

**Example input:**
```
环境192.168.1.1	root	pass1
后台192.168.1.1	admin	pass2
环境192.168.1.2	root	pass3
```

**Result:** Two groups "192.168.1.1" and "192.168.1.2", each containing their respective sessions.

**Session naming:**
- Telnet: `<host>` or `<host>:<port>` (no username prefix)
- SSH: `<username>@<host>` or `<username>@<host>:<port>`

#### Key Functions

- `parse_connection_text()`: Main parser for all input formats
- `parse_single_entry()`: Parses one connection entry with IP scanning
- `find_ipv4_position()`: Scans string to locate IPv4 address position
- `parse_credentials_flexible()`: Parses credentials with tab/slash/space separators
- `is_session_env_info_format()`: Detects 环境/后台 format
- `parse_session_env_info_entry()`: Parses single 环境/后台 entry
- `import_session_env_info()`: Handles grouping and saving for bulk import

## Terminal Reconnection

The terminal supports reconnecting to SSH/Telnet sessions while preserving scrollback history (`crates/terminal/src/terminal.rs`, `crates/terminal_view/src/terminal_view.rs`).

### Architecture

When reconnecting, the existing `Terminal` entity is reused rather than creating a new one:
- The `Term` object (which holds the scrollback buffer) is never replaced
- A new connection is created using the stored `events_tx` sender
- The new connection sends events through the same channel to the existing `Term`

### Key Components

- `events_tx: UnboundedSender<AlacTermEvent>`: Stored in Terminal struct for reuse during reconnection
- `Terminal::reconnect(&self, cx: &App) -> Task<Result<Box<dyn TerminalConnection>>>`: Creates new SSH/Telnet connection using existing `events_tx` and current terminal size
- `Terminal::set_connection(&mut self, connection: Box<dyn TerminalConnection>)`: Updates terminal to use new connection
- `TerminalView::reconnect_terminal()`: Orchestrates reconnection, prints status messages

### Reconnection Flow

1. User triggers reconnect (e.g., presses Enter when disconnected)
2. "Connecting..." message is printed to terminal
3. `terminal.reconnect(cx)` creates new connection with existing `events_tx`
4. On success: `terminal.set_connection(connection)` updates the terminal, "Connected" message printed
5. On failure: Error message printed with retry prompt
6. Scrollback history remains intact throughout

### Usage

```rust
// In terminal_view.rs
fn reconnect_terminal(&mut self, window: &mut Window, cx: &mut Context<Self>) {
    // Print connecting message
    self.terminal.update(cx, |terminal, cx| {
        terminal.write_output(b"\x1b[36mConnecting...\x1b[0m\r\n", cx);
    });

    let reconnect_task = self.terminal.update(cx, |terminal, cx| terminal.reconnect(cx));

    cx.spawn_in(window, async move |this, cx| {
        match reconnect_task.await {
            Ok(connection) => {
                this.update(cx, |this, cx| {
                    this.terminal.update(cx, |terminal, cx| {
                        terminal.set_connection(connection);
                    });
                })?;
            }
            Err(err) => { /* handle error */ }
        }
        anyhow::Ok(())
    }).detach_and_log_err(cx);
}
```

## Editor Panel

The `editor_panel` crate (`crates/editor_panel`) provides a dockable panel for code editing, similar to the main editor but positioned in a dock.

### Architecture

- Wraps a `Pane` containing editor items
- Auto-closes when the last tab is closed (matches TerminalPanel behavior)
- Supports tab bar display and pane splitting

### Key Components

- `EditorPanel`: Main panel struct implementing `Panel`, `Focusable`, `Render`
- `new_editor_pane()`: Creates a configured pane for the editor panel
- `init(cx)`: Registers `ToggleFocus` action

### Integration Points

- **Action**: `zed_actions::editor_panel::ToggleFocus`
- **Position**: Left, Right, or Bottom dock (default: Right)
- **Auto-close**: Panel closes automatically when last tab is closed

## Terminal Python Scripting

The terminal scripting system allows Python scripts to automate terminal sessions via a Unix socket JSON-RPC server.

### Architecture

```
+------------------+     Unix Socket      +--------------------+
|  Python Script   | <------------------> |  Scripting Server  |
|  (bspterm.py)    |    JSON-RPC 2.0      |  (Rust crate)      |
+------------------+                      +--------------------+
        ^                                          |
        |                                 +--------v--------+
+-------+--------+                        | Terminal Entity |
| Script Panel   |                        | (PTY/SSH/Telnet)|
| (UI 管理面板)   |                        +-----------------+
+----------------+
```

### Crates

| Crate | Path | Purpose |
|-------|------|---------|
| `terminal_scripting` | `crates/terminal_scripting/` | Unix socket server, JSON-RPC protocol, terminal registry |
| `script_panel` | `crates/script_panel/` | UI panel for script management and execution |

### Terminal Registry

Terminals are automatically registered when created (`TerminalView::new()`) and tracked for focus changes:

```rust
// In terminal_view.rs
let scripting_id = TerminalRegistry::register(&terminal, term_name, cx);

// On focus
TerminalRegistry::set_focused(Some(id), cx);
```

The registry uses `WeakEntity<Terminal>` references, so terminals are automatically cleaned up when dropped.

### JSON-RPC Methods

| Method | Description |
|--------|-------------|
| `session.current` | Get current focused terminal |
| `session.list` | List all terminal sessions |
| `session.create_ssh` | Create background SSH connection (no UI) |
| `session.create_telnet` | Create background Telnet connection (no UI) |
| `terminal.send` | Send raw input to terminal |
| `terminal.read` | Read current screen content |
| `terminal.wait_for` | Wait for pattern in output (regex) |
| `terminal.run` | Run command and wait for completion |
| `terminal.close` | Close terminal connection |

### Python Client Library

Location: `assets/scripts/bspterm.py` (auto-installed to `~/.config/zed/scripts/`)

```python
from bspterm import current_terminal, Session, SSH, Telnet

# Scenario 1: Operate on focused terminal
term = current_terminal()
output = term.run("ls -la")
print(output)

# Scenario 2: List all sessions
sessions = Session.list()
for s in sessions:
    print(f"{s.id}: {s.name}")

# Scenario 3: Background SSH connection
term = SSH.connect("192.168.1.1", user="root", password="secret")
term.wait_for("$")
output = term.run("hostname")
term.close()

# Scenario 4: Background Telnet connection
term = Telnet.connect("192.168.1.1", port=23)
term.wait_for("login:")
term.send("admin\n")
term.wait_for(">")
output = term.run("show version")
term.close()

# Scenario 5: Interactive commands
term = current_terminal()
term.send("passwd\n")
term.wait_for("New password:")
term.send("newpass123\n")
term.wait_for("Retype")
term.send("newpass123\n")
```

### Script Panel

- **Location**: Bottom dock (View > Script Panel)
- **Action**: `bspterm_actions::script_panel::ToggleFocus`
- **Scripts Directory**: `~/.config/zed/scripts/*.py`

Features:
- Script list with refresh button
- Run/Stop controls
- Real-time output display
- Automatic focus terminal binding (via `BSPTERM_CURRENT_TERMINAL` env var)

### Environment Variables

| Variable | Description |
|----------|-------------|
| `BSPTERM_SOCKET` | Unix socket path for JSON-RPC server |
| `BSPTERM_CURRENT_TERMINAL` | Terminal ID of focused terminal when script started |
| `PYTHONPATH` | Set to scripts directory for `bspterm` module import |

### Testing

1. Build and run: `cargo run`
2. Open a terminal (Ctrl+`)
3. Open Script Panel (View > Script Panel)
4. Create test script `~/.config/zed/scripts/hello.py`:
```python
from bspterm import current_terminal
term = current_terminal()
print(f"Terminal ID: {term.id}")
output = term.run("echo 'Hello from Python!'")
print(f"Output: {output}")
```
5. Click Run and observe output in Script Panel

### Non-blocking I/O

The script runner uses non-blocking I/O to prevent UI hangs:
- stdout/stderr are set to `O_NONBLOCK` via `fcntl`
- `read_output()` handles `WouldBlock` errors gracefully
- Output is polled during render cycles

## Terminal Automation Rules

The terminal includes a rule-based automation system for auto-login and other automated actions (`crates/terminal/src/rule_store.rs`, `crates/terminal/src/rule_engine.rs`, `crates/rule_editor/`).

### Architecture

```
Terminal Event (Wakeup/Connected/Disconnected)
       ↓
  RuleEngine.check(event_type, screen_content)
       ↓
  Filter rules by trigger → Pattern Match? → Execute Action
       ↓
  SendCredential / SendText / RunPython / etc.
```

### Data Structures (`crates/terminal/src/rule_store.rs`)

```rust
pub struct AutomationRule {
    pub id: Uuid,
    pub name: String,
    pub enabled: bool,
    pub trigger: TriggerEvent,      // When to check this rule
    pub max_triggers: Option<u32>,  // Max times to trigger per connection (None = unlimited)
    pub condition: RuleCondition,
    pub action: RuleAction,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]
pub enum TriggerEvent {
    #[default]
    Wakeup,       // New output received (most common)
    Connected,    // Connection established
    Disconnected, // Connection lost
}

pub enum RuleCondition {
    Pattern { pattern: String, case_insensitive: bool },
    ConnectionType { protocol: Protocol },  // Ssh or Telnet
    All { conditions: Vec<RuleCondition> }, // AND logic
    Any { conditions: Vec<RuleCondition> }, // OR logic
}

pub enum RuleAction {
    SendText { text: String, append_newline: bool },
    SendCredential { credential_type: CredentialType }, // Username or Password
    RunPython { code: String },
    Sequence { actions: Vec<RuleAction> },
    Delay { milliseconds: u64 },
}
```

### RuleStore and GPUI Integration

- `RuleStore`: Holds rules, handles save/load from JSON
- `RuleStoreEntity`: GPUI entity with auto-save and event emission
- `RuleStoreEvent`: Events for UI subscription (Changed, RuleAdded, RuleRemoved)

```rust
// Initialize on app startup
RuleStoreEntity::init(cx);

// Access globally
let rules = RuleStoreEntity::global(cx);
rules.update(cx, |store, cx| {
    store.add_rule(rule, cx);
});

// Subscribe to changes
cx.subscribe(&rules, |this, _, event, cx| {
    // Handle RuleStoreEvent
});
```

### Persistence

Rules are stored in `~/.config/zed/terminal_rules.json` (via `paths::terminal_rules_file()`).

### RuleEngine (`crates/terminal/src/rule_engine.rs`)

The rule engine compiles regex patterns at initialization and tracks trigger counts per connection.

```rust
// Create engine with connection info and rules
let engine = RuleEngine::new(&connection_info, &rules);

// Check rules for a trigger event
let actions = engine.check(TriggerEvent::Wakeup, &screen_content);

// Execute matched actions
for action in actions {
    match action.action {
        RuleAction::SendCredential { credential_type } => {
            if let Some(cred) = engine.get_credential(&credential_type) {
                terminal.input(format!("{}\n", cred).into_bytes());
            }
        }
        RuleAction::SendText { text, append_newline } => { /* ... */ }
        // ...
    }
}
```

**Key features:**
- Pre-compiled regex patterns for performance
- Cooldown mechanism (2 seconds) prevents rapid repeated triggering
- `max_triggers` limit per rule per connection
- `reset_counts()` for reconnection scenarios

### Terminal Integration

The rule engine is integrated into `Terminal` (`crates/terminal/src/terminal.rs`):

- `init_rule_engine()`: Called when connection is established
- `check_rules(trigger, cx)`: Called on Wakeup events (new output) and connection state changes
- `execute_rule_action(action, cx)`: Executes matched actions

### Rule Editor Panel (`crates/rule_editor/`)

A dockable panel for managing automation rules.

**Module Structure:**
```
crates/rule_editor/
├── Cargo.toml
└── src/
    ├── rule_editor.rs       # Main panel with rule list
    └── rule_edit_modal.rs   # Modal for creating/editing rules
```

**Panel Features:**
- List of rules with enable/disable checkboxes
- Edit and Delete buttons per rule
- "Add Rule" button to create new rules
- Subscribes to `RuleStoreEntity` for automatic updates

**Modal Features:**
- Name, Pattern (regex), and Send Text input fields
- Trigger selection (Wakeup, Connected)
- Protocol selection (Telnet, SSH)
- Action type selection (Send Credential, Send Text)
- Credential type selection (Username, Password)

### Integration Points

- **Action**: `bspterm_actions::rule_editor::ToggleFocus`
- **Position**: Right dock
- **Icon**: Cog icon
- **Priority**: `activation_priority = 11`

### Default Auto-Login Rules

Default rules are stored in `assets/settings/default_terminal_rules.json`:

```json
{
  "rules": [
    {
      "name": "Telnet Username Prompt",
      "enabled": true,
      "trigger": "Wakeup",
      "max_triggers": 1,
      "condition": {
        "type": "All",
        "conditions": [
          { "type": "ConnectionType", "protocol": "Telnet" },
          { "type": "Pattern", "pattern": "(?i)(username|login|user)\\s*:", "case_insensitive": true }
        ]
      },
      "action": { "type": "SendCredential", "credential_type": "Username" }
    },
    {
      "name": "Telnet Password Prompt",
      "enabled": true,
      "trigger": "Wakeup",
      "max_triggers": 1,
      "condition": {
        "type": "All",
        "conditions": [
          { "type": "ConnectionType", "protocol": "Telnet" },
          { "type": "Pattern", "pattern": "(?i)password\\s*:", "case_insensitive": true }
        ]
      },
      "action": { "type": "SendCredential", "credential_type": "Password" }
    }
  ]
}
```

### Testing

Run rule engine tests:
```sh
cargo test -p terminal rule_engine
```

Tests cover:
- Pattern matching (case-sensitive and case-insensitive)
- Connection type conditions
- max_triggers limit enforcement
- Trigger event filtering
- Any/All condition logic
- Credential retrieval
- Disabled rules ignored
- Reset counts functionality
